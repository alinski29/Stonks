var documenterSearchIndex = {"docs":
[{"location":"advanced_usage.html#Advanced-usage","page":"Advanced usage","title":"Advanced usage","text":"","category":"section"},{"location":"advanced_usage.html","page":"Advanced usage","title":"Advanced usage","text":"","category":"page"},{"location":"advanced_usage.html#Plug-in-any-data-format","page":"Advanced usage","title":"Plug in any data format","text":"","category":"section"},{"location":"advanced_usage.html","page":"Advanced usage","title":"Advanced usage","text":"The FileStore uses CSV as the default format for reading and writing data. If you wish more performance, you are free to use it with any format you like.  You just need to provide functions for reading and writing data with your format.  Here's an example using the Arrow file format.","category":"page"},{"location":"advanced_usage.html","page":"Advanced usage","title":"Advanced usage","text":"using Arrow, Dates, DataFrames\nusing Stonks\n\nfunction write_arrow(df::AbstractDataFrame, path::String)\n  open(path, \"w\") do io\n    Arrow.write(io, df)\n  end\nend\nread_arrow(path::String) = DataFrame(Arrow.Table(path))\n\nds = FileStore{AssetPrice}(;\n  path=joinpath(@__DIR__, \"data/arrow\"),\n  ids=[:symbol],\n  format=\"arrow\",\n  time_column=\"date\",\n  reader=read_arrow,\n  writer=write_arrow,\n)\n\ndata = [\n  AssetPrice(; symbol=\"MSFT\", date=Date(\"2022-02-16\"), close=299.5),\n  AssetPrice(; symbol=\"MSFT\", date=Date(\"2022-02-17\"), close=290.73),\n  AssetPrice(; symbol=\"AAPL\", date=Date(\"2022-02-17\"), close=168.88),\n  AssetPrice(; symbol=\"AAPL\", date=Date(\"2022-02-18\"), close=167.3),\n]\n\nsave(ds, data)\nreaddir(ds.path)\n1-element Vector{String}:\n \"data.arrow\"\n\ndf = load(ds)\nshow(df)\n4×8 DataFrame\n Row │ symbol  date        close    open      high      low       close_adjusted  volume   \n     │ String  Date        Float64  Float64?  Float64?  Float64?  Float64?        Integer? \n─────┼─────────────────────────────────────────────────────────────────────────────────────\n   1 │ MSFT    2022-02-16   299.5    missing   missing   missing         missing   missing \n   2 │ MSFT    2022-02-17   290.73   missing   missing   missing         missing   missing \n   3 │ AAPL    2022-02-17   168.88   missing   missing   missing         missing   missing \n   4 │ AAPL    2022-02-18   167.3    missing   missing   missing         missing   missing ","category":"page"},{"location":"advanced_usage.html","page":"Advanced usage","title":"Advanced usage","text":"","category":"page"},{"location":"advanced_usage.html#Create-API-resources-for-your-custom-models","page":"Advanced usage","title":"Create API resources for your custom models","text":"","category":"section"},{"location":"advanced_usage.html","page":"Advanced usage","title":"Advanced usage","text":"Assume we'll receive the following content from an API. Source: https://www.alphavantage.co/query?function=INFLATION&apikey=demo","category":"page"},{"location":"advanced_usage.html","page":"Advanced usage","title":"Advanced usage","text":" {\n  \"name\": \"Inflation - US Consumer Prices\",\n  \"interval\": \"annual\",\n  \"unit\": \"percent\",\n  \"data\": [\n    {\"date\": \"2020-01-01\", \"value\": \"1.2335\"},\n    {\"date\": \"2019-01-01\", \"value\": \"1.8122\"}\n  ]\n}","category":"page"},{"location":"advanced_usage.html","page":"Advanced usage","title":"Advanced usage","text":"using Chain, Dates, JSON3\nusing Stonks: Stonks, APIResource, JSONParser\n\n# Create your custom type\nstruct MacroIndicator <: AbstractStonksRecord\n  name::String\n  date::Date\n  value::Number\nend\n\n# Define a function with the same signature as `parse_conent`\n# parse_content(content::AbstractString; kwargs...) -> Vector{<:AbstractStonksRecord}\nfunction parse_inflation_data(content::AbstractString; kwargs...)\n  js = JSON3.read(content)\n  from, to = get(kwargs, :from, missing), get(kwargs, :to, missing)\n  return @chain js[\"data\"] begin \n    map(x -> MacroIndicator(\n      \"US Consumer Prices\", tryparse(Date, x[:date]), tryparse(Float64, x[:value])), _,\n    )\n    isa(from, Date) ? filter(row -> row.date >= from, _) : _\n    isa(to, Date) ? filter(row -> row.date <= to, _) : _\n  end\nend\n\n# Define an API resource, wrap your function around a subtype of AbstractContentParser.\n# subtypes(Stonks.Parsers.AbstractContentParser)\n# [Stonks.Parsers.JSONParser, Stonks.Parsers.CSVParser]\nmy_resource = APIResource{MacroIndicator}(;\n  url=\"https://www.alphavantage.co/query\",\n  headers=Dict(\"accept\" => \"application/json\"),prices\n  query_params=Dict(\"function\" => \"INFLATION\", \"apikey\" => \"demo\"),\n  parser=Stonks.JSONParser(parse_inflation_data),\n)\n\ndata = get_data(my_resource; from=Date(\"2019-01-01\"))\nforeach(println, data)\nMacroIndicator(\"US Consumer Prices\", Date(\"2020-01-01\"), 1.23358439630637)\nMacroIndicator(\"US Consumer Prices\", Date(\"2019-01-01\"), 1.81221007526015)\n\n# convert it to a dataframe - types are preserved.\nto_dataframe(data)\n2×3 DataFrame\n Row │ name       date        value   \n     │ String     Date        Number  \n─────┼────────────────────────────────\n   1 │ US Consumer Prices  2020-01-01  1.23358\n   2 │ US Consumer Prices  2019-01-01  1.81221","category":"page"},{"location":"advanced_usage.html","page":"Advanced usage","title":"Advanced usage","text":"","category":"page"},{"location":"advanced_usage.html#Create-your-client-from-combining-API-resources","page":"Advanced usage","title":"Create your client from combining API resources","text":"","category":"section"},{"location":"advanced_usage.html","page":"Advanced usage","title":"Advanced usage","text":"using Stonks: Stonks, APIClient\n\nyc = YahooClient(\"<my_secret_key>\")\nac = AlphavantageJSONClient(\"<my_secret_key>\")\n\nmy_client = Stonks.APIClient(Dict(\n  \"price\" => ac.resources[\"price\"],\n  \"info\" => yc.resources[\"info\"],\n  \"exchange\" => yc.resources[\"exchange\"], \n  # ... + your own custom resources\n))\nStonks.APIClients.get_supported_types(my_client)\n3-element Vector{DataType}:\n ExchangeRate\n AssetPrice\n AssetInfo","category":"page"},{"location":"api_functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"api_functions.html#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"Pages = [\"api_functions.md\"]","category":"page"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"api_functions.html#Client-setup","page":"Functions","title":"Client setup","text":"","category":"section"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"The library comes with methods for creating APIClient instances with preconfigured data for these providers:","category":"page"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"YahooClient\nAlphavantageJSONClient","category":"page"},{"location":"api_functions.html#Stonks.APIClients.YahooClient","page":"Functions","title":"Stonks.APIClients.YahooClient","text":"YahooClient(api_key::String) -> APIClient\n\nUtility function for creating a client for accessing yahoofinance API.  Contains the following resources: \n\ninfo => APIResource{AssetInfo}\nprice => APIResource{AssetPrice}\nexchange => APIResource{ExchangeRate}\n\n\n\n\n\n","category":"function"},{"location":"api_functions.html#Stonks.APIClients.AlphavantageJSONClient","page":"Functions","title":"Stonks.APIClients.AlphavantageJSONClient","text":"AlphavantageJSONClient(api_key::String) -> APIClient\n\nUtility function for creating a client for accessing alphavantage API.  Contains the following resources: \n\ninfo => APIResource{AssetInfo}\nprice => APIResource{AssetPrice}\nexchange => APIResource{ExchangeRate}\n\n\n\n\n\n","category":"function"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"You can omit the client parameter in all functions IF you set an environment variables:","category":"page"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"Alphavantage: ALPHAVANTAGE_TOKEN => will build an APIClient using AlphavantageJSONClient \nYahoo Finance: YAHOOFINANCE_TOKEN => will build an APIClient using YahooClient","category":"page"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"api_functions.html#Retrieving-data","page":"Functions","title":"Retrieving data","text":"","category":"section"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"get_price\nget_info\nget_exchange_rate\nget_data","category":"page"},{"location":"api_functions.html#Stonks.get_price","page":"Functions","title":"Stonks.get_price","text":"get_price(\n  symbols, [client], [T<:AbstractStonksRecord];\n  [interval] = \"1d\", [from] = missing, [to] = missing, [kwargs...]\n) -> Union{Vector{T}, Exception}\n\nRetrieves historical time series price data from the configured API client.\n\nArguments\n\nsymbols can be:\nString with one symbol / ticker\nVector{String} with multiple symbols\nVector{Tuple{String, Date}}: tuples of form (symbol, from)\nVector{Tuple{String, Date, Date}}, tuples of form (symbol, from, to)\n[client::APIClient]: can be ommited if one of the correct environmental variable is set (YAHOOFINANCE_TOKEN or ALPHAVANTAGE_TOKEN)\n[T<:AbstractStonksRecord]: data type used for parsing. Change it only if you want to use your custom model. default = AssetPrice\n\nKeywords\n\n[interval]: values = [1d, 1wk, 1mo]. Frequency lower than daily is not supported. default = 1d\n[from]: a Date oject indicating lower date limit. default = missing\n[to]: a Date objject indicating upper date limit. default = missing\n[kwargs...]: use it to pass keyword arguments if you have url / query parameters that need to be resolved at runtime.\n\nExamples\n\njulia> today = Dates.today()\n2022-02-18\njulia> length(ENV[\"YAHOOFINANCE_TOKEN\"]) # value will be used to create a client\n40\njulia> get_price(\"AAPL\", from = today - Dates.Day(1))\n1-element Vector{AbstractStonksRecord}\n AssetPrice(\"AAPL\", Date(\"2022-02-17\"), 168.88, missing, missing, missing, missing, missing)\n AssetPrice(\"AAPL\", Date(\"2022-02-18\"), 167.3, missing, missing, missing, missing, missing)\n\njulia> from = today - Dates.Day(2)\n2022-02-16\njulia> prices = get_price([\"AAPL\", \"MSFT\"], from = from)\nAssetPrice(\"MSFT\", Date(\"2022-02-16\"), 299.5, missing, missing, missing, missing, missing)\nAssetPrice(\"MSFT\", Date(\"2022-02-17\"), 290.73, missing, missing, missing, missing, missing\nAssetPrice(\"MSFT\", Date(\"2022-02-18\"), 287.93, missing, missing, missing, missing, missing\nAssetPrice(\"AAPL\", Date(\"2022-02-16\"), 172.55, missing, missing, missing, missing, missing\nAssetPrice(\"AAPL\", Date(\"2022-02-17\"), 168.88, missing, missing, missing, missing, missing\nAssetPrice(\"AAPL\", Date(\"2022-02-18\"), 167.3, missing, missing, missing, missing, missing)\n\njulia> prices = get_price([\n  (\"AAPL\", Date(\"2022-02-17\")),\n  (\"MSFT\", Date(\"2022-02-18\"))\n  ])\n3-element Vector{AbstractStonksRecord}:\n AssetPrice(\"AAPL\", Date(\"2022-02-17\"), 168.88, missing, missing, missing, missing, missing)\n AssetPrice(\"AAPL\", Date(\"2022-02-18\"), 167.3, missing, missing, missing, missing, missing)\n AssetPrice(\"MSFT\", Date(\"2022-02-18\"), 287.93, missing, missing, missing, missing, missing)\n\njulia> prices = get_price([\n  (\"AAPL\", Date(\"2022-02-15\"), Date(\"2022-02-16\")),\n  (\"MSFT\", Date(\"2022-02-14\"), Date(\"2022-02-15\"))\n  ])\n5-element Vector{AbstractStonksRecord}:\n AssetPrice(\"MSFT\", Date(\"2022-02-14\"), 295.0, missing, missing, missing, missing, missing)\n AssetPrice(\"MSFT\", Date(\"2022-02-15\"), 300.47, missing, missing, missing, missing, missing)\n AssetPrice(\"AAPL\", Date(\"2022-02-15\"), 172.79, missing, missing, missing, missing, missing)\n AssetPrice(\"AAPL\", Date(\"2022-02-16\"), 172.55, missing, missing, missing, missing, missing)\n\n\n\n\n\n","category":"function"},{"location":"api_functions.html#Stonks.get_info","page":"Functions","title":"Stonks.get_info","text":"get_info(symbols, [client], [T<:AbstractStonksRecord]) -> Union{Vector{T}, Exception}\n\nRetrieves general information about symbols.\n\nArguments\n\nsymbols::Union{String, Vector{String}}\n[client]::APIClient : can be ommited if one of the correct environmental variable is set (YAHOOFINANCE_TOKEN or ALPHAVANTAGE_TOKEN)\n[T<:AbstractStonksRecord] : data type used for parsing. Change it only if you want to use your custom model. default = AssetInfo\n\nExamples\n\njulia> get_info(client, \"AAPL\")\n1-element Vector{AssetInfo}:\n AssetInfo(\"AAPL\", \"USD\", \"Apple Inc.\", \"EQUITY\", \"NMS\", \"United States\",\n  \"Consumer Electronics\", \"Technology\", \"America/New_York\", 100000)\n\njulia> length(ENV[\"YAHOOFINANCE_TOKEN\"]) # value will be used to create a client\n40\njulia> get_info([\"AAPL\", \"MSFT\"])\n2-element Vector{AssetInfo}:\n AssetInfo(\"AAPL\", \"USD\", \"Apple Inc.\", \"EQUITY\", \"NMS\", \"United States\",\n  \"Consumer Electronics\", \"Technology\", \"America/New_York\", 100000)\n AssetInfo(\"MSFT\", \"USD\", \"Microsoft Corporation\", \"EQUITY\", \"NMS\", \"United States\",\n  \"Software—Infrastructure\", \"Technology\", \"America/New_York\", 181000)\n\n\n\n\n\n","category":"function"},{"location":"api_functions.html#Stonks.get_exchange_rate","page":"Functions","title":"Stonks.get_exchange_rate","text":"get_exchange_rate(\n  symbols, [client], [T<:AbstractStonksRecord]; \n  [from] = missing, [to] = missing\n) -> Union{Vector{T}, Exception}\n\nRetrieves historical exchange rate information\n\nArguments\n\nsymbols can be:\nString formated as base/quote, each having exactly 3 characters, e.g.: 'EUR/USD', 'USD/CAD'\nVector{String} with multiple symbols\nVector{Tuple{String, Date}}: tuples of form (symbol, from)\nVector{Tuple{String, Date, Date}}, tuples of form (symbol, from, to)\n[client]::APIClient can be omitted if one of the correct environmental variable is set (YAHOOFINANCE_TOKEN or ALPHAVANTAGE_TOKEN)\n[T<:AbstractStonksRecord] is the data type used for parsing. Change it only if you want to use your custom model. default = ExchangeRate\n\nKeywords\n\n[from]: a Date object. default = missing\n[to]: a Date object. default = missing\n\nExamples\n\njulia> get_exchange_rate(\"EUR/USD\", from=ref_date-Day(1), to=ref_date)\n3-element Vector{ExchangeRate}:\n ExchangeRate(\"EUR\", \"USD\", Date(\"2022-02-18\"), 1.13203)\n ExchangeRate(\"EUR\", \"USD\", Date(\"2022-02-17\"), 1.13592)\njulia> get_exchange_rate([\"EUR/USD\", \"USD/CAD\"], from=ref_date-Day(1), to=ref_date)\n# 4-element Vector{ExchangeRate}:\n ExchangeRate(\"EUR\", \"USD\", Date(\"2022-02-18\"), 1.13203)\n ExchangeRate(\"EUR\", \"USD\", Date(\"2022-02-17\"), 1.13592)\n ExchangeRate(\"USD\", \"CAD\", Date(\"2022-02-18\"), 1.2748)\n ExchangeRate(\"USD\", \"CAD\", Date(\"2022-02-17\"), 1.2707)\n# Also works with []Tuple{String, Date} or []Tuple{String, Date, Date}\njulia>get_exchange_rate([\n  (\"EUR/USD\", Date(\"2022-02-15\"), Date(\"2022-02-16\")),\n  (\"USD/CAD\", Date(\"2022-02-14\"), Date(\"2022-02-15\")),\n])\n4-element Vector{ExchangeRate}:\n...\n\n\n\n\n\n","category":"function"},{"location":"api_functions.html#Stonks.get_data","page":"Functions","title":"Stonks.get_data","text":"get_data(resource, symbols; kwargs...) -> Union{Vector{<:AbstractStonksRecord}, Exception}\n\nGeneric function to get data of type resource{T}. Functions such as getprice, getinfo, call this.\n\nArguments\n\nresource::APIResource: instance of an APIResource.\nsymbols::Symbol can be:\nString with one symbol / ticker\nVector{String} with multiple symbols\nVector{Tuple{String, Date}}: tuples of form (symbol, from)\nVector{Tuple{String, Date, Date}}, tuples of form (symbol, from, to)\nVector{UpdatableSymbol}: type Stonks.UpdatableSymbol(symbol; [from], [to])\n\nKeywords\n\n[interval]: values = 1d, 1wk, 1mo. Frequency lower than daily is not supported. default = 1d\n[from]: a Date oject indicating lower date limit. default = missing\n[to]: a Date objject indicating upper date limit. default = missing\n[kwargs...]: use it to pass keyword arguments if you have url / query parameters that need to be resolved at runtime.\n\n\n\n\n\n","category":"function"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"api_functions.html#DataFrame-conversion","page":"Functions","title":"DataFrame conversion","text":"","category":"section"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"to_dataframe","category":"page"},{"location":"api_functions.html#Stonks.to_dataframe","page":"Functions","title":"Stonks.to_dataframe","text":"to_dataframe(data::Vecotr{<:AbstractStonksRecord}) -> DataFrame\n\nConverts an object of type Vector{<:AbstractStonksRecord} to a DataFrame. The types of the DataFrame will match the types of T.\n\nExamples\n\njulia> data\n4-element Vector{AssetPrice}:\n AssetPrice(\"MSFT\", Date(\"2022-02-23\"), 280.27, 290.18, 291.7, 280.1, missing, 37811167)\n AssetPrice(\"MSFT\", Date(\"2022-02-22\"), 287.72, 285.0, 291.54, 284.5, missing, 41569319)\n AssetPrice(\"AAPL\", Date(\"2022-02-23\"), 160.07, 165.54, 166.15, 159.75, missing, 90009247)\n AssetPrice(\"AAPL\", Date(\"2022-02-22\"), 164.32, 164.98, 166.69, 162.15, missing, 90457637)\njulia> data |> to_dataframe\n4x8 DataFrame\n Row │ symbol  date        close    open      high      low       close_adjusted  volume   \n     │ String  Date        Float64  Float64?  Float64?  Float64?  Float64?        Int64?   \n─────┼─────────────────────────────────────────────────────────────────────────────────────\n   1 │ MSFT    2022-02-23   280.27    290.18    291.7     280.1          missing  37811167\n   2 │ MSFT    2022-02-22   287.72    285.0     291.54    284.5          missing  41569319\n   3 │ AAPL    2022-02-23   160.07    165.54    166.15    159.75         missing  90009247\n   4 │ AAPL    2022-02-22   164.32    164.98    166.69    162.15         missing  90457637\n\njulia> data\n3-element Vector{ExchangeRate}:\n ExchangeRate(\"EUR\", \"USD\", Date(\"2022-02-16\"), 1.13721)\n ExchangeRate(\"EUR\", \"USD\", Date(\"2022-02-15\"), 1.1358)\n ExchangeRate(\"EUR\", \"USD\", Date(\"2022-02-14\"), 1.13052)\njulia> data |> to_dataframe\n3x4 DataFrame\n Row │ base    target  date        rate    \n     │ String  String  Date        Float64 \n─────┼─────────────────────────────────────\n   1 │ EUR     USD     2022-02-16  1.13721\n   2 │ EUR     USD     2022-02-15  1.1358\n   3 │ EUR     USD     2022-02-14  1.13052\n\n\n\n\n\n","category":"function"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"api_functions.html#Persisting-data","page":"Functions","title":"Persisting data","text":"","category":"section"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"load\nsave\nupdate","category":"page"},{"location":"api_functions.html#Stonks.Stores.load","page":"Functions","title":"Stonks.Stores.load","text":"load(ds, [partitions]) -> Union{DataFrame, Exception}\n\nRead data from an FileStore instance into a DataFrame. If there is no data at ds.path, a file with 0 records and the correct types with be created. \n\nArguments\n\nds::FileStore{<:AbstractStonksRecord}: a FileStore instance\n[partitions]::Dict{String, Vector{String}}: a dict of column => values, used for partition pruning. default = missing\n\nExamples\n\ndest = joinpath(@__DIR__, \"data/prices\")\nds = FileStore{AssetPrice}(; path=dest, ids=[:symbol], partitions=[:symbol], time_column=\"date\")\ndf = load(ds)\nshow(df[1:2, :]) # types are persisted\n2×8 DataFrame\n Row │ symbol  date        close    open      high      low       close_adjusted  volume   \n     │ String  Date        Float64  Float64?  Float64?  Float64?  Float64?        Integer? \n─────┼─────────────────────────────────────────────────────────────────────────────────────\n   1 │ AAPL    2022-03-01   163.2    164.695    166.6     161.97         missing  83474425\n   2 │ AAPL    2022-02-28   165.12   163.06     165.42    162.43         missing  95056629\n\n\n\n\n\n","category":"function"},{"location":"api_functions.html#Stonks.Stores.save","page":"Functions","title":"Stonks.Stores.save","text":"save(ds, data) -> Union{Nothing, Exception}\n\nWrites data using the information provided in the FileStore (path, format,  partitions, writer) In case of a FileStore with partitions, the partition values where data has records will be overwritten.\n\nArguments\n\nds::FileStore\ndata::Union{AbstractDataFrame, Vector{<:AbstractStonksRecord}}\n\nExamples\n\njulia> dest = joinpath(@__DIR__, \"data/prices\")\njulia> ds = FileStore{AssetPrice}(; path=dest, ids=[\"symbol\"], partitions=[\"symbol\"], time_column=\"date\")\njulia> data\n2-element Vector{AssetPrice}:\n AssetPrice(\"MSFT\", Date(\"2022-03-04\"), 289.86, missing, missing, missing, missing, missing)\n AssetPrice(\"TSLA\", Date(\"2022-03-04\"), 838.29, missing, missing, missing, missing, missing)\njulia> save(ds, data)\njulia> readdir(ds.path)\n2-element Vector{String}:\n \"symbol=MSFT\"\n \"symbol=TSLA\"\n\n\n\n\n\n","category":"function"},{"location":"api_functions.html#Stonks.Stores.update","page":"Functions","title":"Stonks.Stores.update","text":"update(ds, [symbols], [client]; [to], [force]) -> Union{Nothing, FileStore}\n\nUpdates or inserts data in the datastore.  If symbols are not provided, the updates will be inferred based on ds.ids and ds.time_column. If symbols are provided, only the symbols will be updated.\n\nArguments\n\nds::FileStore{<:AbstractStonksRecord} \n[symbols::Symbol]. Default = missing.  Can be:\nString with one symbol / ticker\nVector{String} with multiple symbols\nVector{Tuple{String, Date}}: tuples of form (symbol, from)\nVector{Tuple{String, Date, Date}}, tuples of form (symbol, from, to)\n[client::APIClient]: can be omitted if the one of the client can be built from ENV vars\n\nKeywords\n\n[to::Date]: default = most recent working day. upper date limit.\n[force::Bool]: default = false. Indicates how to handle the case when ismissing(ds.time_column) && ismissing(symbols):\nfalse => does nothing\ntrue => makes requests for all ds.ids from the min until max ds.time_column and rewrites all data\n\nExamples\n\njulia> Dates.today()\nDate(\"2022-02-04\")\njulia> @chain load(ds) to_dataframe groupby(_, :symbol) combine(_, :date => maximum) show\n2×2 DataFrame\n Row │ symbol  date_maximum \n     │ String  Date         \n─────┼──────────────────────\n   1 │ MSFT    2022-03-02\n   2 │ AAPL    2022-03-02\njulia> update(ds) \njulia> @chain load(ds) groupby(_, :symbol) combine(_, :date => maximum) show\n2×2 DataFrame\n Row │ symbol  date_maximum \n     │ String  Date         \n─────┼──────────────────────\n   1 │ AAPL    2022-03-04\n   2 │ MSFT    2022-03-04\njulia> update(ds, [\"IBM\", \"AMD\"])\njulia> @chain load(ds) groupby(_, :symbol) combine(_, :date => maximum) show\n4x2 DataFrame\n Row │ symbol  date_maximum \n     │ String  Date         \n─────┼──────────────────────\n   1 │ AAPL    2022-03-04\n   2 │ MSFT    2022-03-04\n   3 │ IBM     2022-03-04\n   3 │ AMD     2022-03-04\n\n\n\n\n\n","category":"function"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"api_functions.html#Content-parsers","page":"Functions","title":"Content parsers","text":"","category":"section"},{"location":"api_functions.html","page":"Functions","title":"Functions","text":"Stonks.Parsers.parse_content","category":"page"},{"location":"api_functions.html#Stonks.Parsers.parse_content","page":"Functions","title":"Stonks.Parsers.parse_content","text":"parse_content(p::AbstractContentParser, c::AbstractString; kwargs...) -> Vector{T<:AbstractStonksRecord}\n\nInterface for parsing raw data into a data model.  All main functions responsible for getting data from APIs will call parse_content with a concrete subtype of AbstractContentParser.\n\nExample - Create a custom type and parser\n\nusing Dates, JSON3, Stonks\n\n# Assume we have the following raw data\njulia> content\n{\n  \"name\": \"Inflation - US Consumer Prices\",\n  \"interval\": \"annual\",\n  \"unit\": \"percent\",\n  \"data\": [\n    {\"date\": \"2020-01-01\", \"value\": \"1.2335\"},\n    {\"date\": \"2019-01-01\", \"value\": \"1.8122\"}\n  ]\n}\n\n# Create your custom type\nstruct MacroIndicator <: AbstractStonksRecord\n  name::String\n  date::Date\n  value::Number\nend\n\n# Define a function with the same signature as parse_content.\nfunction parse_inflation_data(content::AbstractString; kwargs...)\n  js = JSON3.read(content)\n  return map(x -> \n    MacroIndicator(\"Inflation\", tryparse(Date, x[:date]), tryparse(Float64, x[:value])),\n  js[\"data\"])\nend\n\n# Wrap it around a concrete subtype of AbstractContentParser\nmy_parser = Stonks.Parsers.JSONParser(parse_inflation_data)\njulia> parse_content(my_parser, content)\n2-element Vector{MacroIndicator}:\n MacroIndicator(\"Inflation\", Date(\"2020-01-01\"), 1.2335)\n MacroIndicator(\"Inflation\", Date(\"2019-01-01\"), 1.8122)\n\n\n\n\n\n","category":"function"},{"location":"contributing.html#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"The project uses git-flow workflow.  If you want to add a new feature, open a branch feature/feature-name and make a PR to develop branch. Reporting issues in Github issues is highly appreciated.","category":"page"},{"location":"basic_usage.html#Basic-usage","page":"Basic usage","title":"Basic usage","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"","category":"page"},{"location":"basic_usage.html#Installation","page":"Basic usage","title":"Installation","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"using Pkg\nPkg.add(\"Stonks\")","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"If for some reason, the package is not available within the Julia Pkg ecosystem, you can install it from Github","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"using Pkg\nPkg.dev(\"https://github.com/alinski29/Stonks.jl\")","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Throughout the rest of the tutorial we will assume that you have installed the Stonks.jl package and have already typed using Stonks which loads the package.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"","category":"page"},{"location":"basic_usage.html#Client-setup","page":"Basic usage","title":"Client setup","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"For retrieving data from the web, you'll need an instance of Stonks.APIClient, which holds all relevant information for requesting the data. There are currently two data providers supported:","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Yahoo Finance\nAlphavantage","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"For any provider, you need to sign up on the website and obtain a token.  Then, you can load a client using one of the following functions.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"client = YahooClient(\"<my_token>\")\n# or client = AlphavantageJSONClient(\"<my_token>\")","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"","category":"page"},{"location":"basic_usage.html#Client-resolution-fron-ENV-variables","page":"Basic usage","title":"Client resolution fron ENV variables","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"You can omit the client parameter in all functions IF you set one of the environment variables:","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"For Alphavantage: ALPHAVANTAGE_TOKEN => will build an APIClient using AlphavantageJSONClient\nFor Yahoo Finance: YAHOOFINANCE_TOKEN => will build an APIClient using YahooClient","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"In your terminal, type:","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"export ALPHAVANTAGE_TOKEN='MY_TOKEN'\necho $ALPHAVANTAGE_TOKEN\nMY_TOKEN","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> ENV[\"ALPHAVANTAGE_TOKEN\"]\n\"MY_TOKEN\"","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"","category":"page"},{"location":"basic_usage.html#Get-price-time-series","page":"Basic usage","title":"Get price time series","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"using Dates\n\n# Create a  client\nclient = YahooClient(\"<api_key>\") # or AlphavantageJSONClient(<api_key>)\njulia> ref_date = Date(\"2022-02-18\") # just for reproducible results, you can omit it\n2022-02-18\n\n# 'to' can be ommited, defaults to current day.\njulia> get_price(\"AAPL\", client; from=ref_date-Day(1), to=ref_date)\n2-element Vector{AssetPrice}:\n AssetPrice(\"AAPL\", Date(\"2022-02-18\"), 167.3, 169.82, 170.5413, 166.19, missing, 82772674)\n AssetPrice(\"AAPL\", Date(\"2022-02-17\"), 168.88, 171.03, 171.91, 168.47, missing, 69589344)\n # you can omit the client if you have the correct environment variables set\njulia> length(ENV[\"ALPHAVANTAGE_TOKEN\"]) # ENV[\"YAHOOFINANCE_TOKEN\"] works as well\n16\njulia> prices = get_price([\"AAPL\", \"MSFT\"]; from=ref_date-Day(2), to=ref_date) \n6-element Vector{AssetPrice}:\n AssetPrice(\"AAPL\", Date(\"2022-02-18\"), 167.3, 169.82, 170.5413, 166.19, missing, 82772674)\n AssetPrice(\"AAPL\", Date(\"2022-02-17\"), 168.88, 171.03, 171.91, 168.47, missing, 69589344)\n AssetPrice(\"AAPL\", Date(\"2022-02-16\"), 172.55, 171.85, 173.34, 170.05, missing, 61177398)\n AssetPrice(\"MSFT\", Date(\"2022-02-18\"), 287.93, 293.05, 293.86, 286.305, missing, 34264008)\n AssetPrice(\"MSFT\", Date(\"2022-02-17\"), 290.73, 296.36, 296.8, 290.0, missing, 32461580)\n AssetPrice(\"MSFT\", Date(\"2022-02-16\"), 299.5, 298.365, 300.87, 293.68, missing, 29982121)\n# you can query each symbol with different time intervals\njulia> prices = get_price([\n  (\"AAPL\", Date(\"2022-02-15\"), Date(\"2022-02-16\")),\n  (\"MSFT\", Date(\"2022-02-14\"), Date(\"2022-02-15\")),\n])\n4-element Vector{AssetPrice}:\n AssetPrice(\"MSFT\", Date(\"2022-02-15\"), 300.47, 300.008, 300.8, 297.02, missing, 27379488)\n AssetPrice(\"MSFT\", Date(\"2022-02-14\"), 295.0, 293.77, 296.76, 291.35, missing, 36359487)\n AssetPrice(\"AAPL\", Date(\"2022-02-16\"), 172.55, 171.85, 173.34, 170.05, missing, 61177398)\n AssetPrice(\"AAPL\", Date(\"2022-02-15\"), 172.79, 170.97, 172.95, 170.25, missing, 64286320)","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"","category":"page"},{"location":"basic_usage.html#Get-asset-information","page":"Basic usage","title":"Get asset information","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> get_info(\"AAPL\")\n1-element Vector{AssetInfo}:\n AssetInfo(\"AAPL\", \"USD\", \"Apple Inc\", \"Common Stock\", \"NASDAQ\", \"USA\", \"Electronic Computers\", \"Technology\", missing, missing)\n\njulia> get_info([\"AAPL\", \"MSFT\"])\n2-element Vector{AssetInfo}:\n AssetInfo(\"MSFT\", \"USD\", \"Microsoft Corporation\", \"Common Stock\", \"NASDAQ\", \"USA\", \"Services-Prepackaged Software\", \"Technology\", missing, missing)\n AssetInfo(\"AAPL\", \"USD\", \"Apple Inc\", \"Common Stock\", \"NASDAQ\", \"USA\", \"Electronic Computers\", \"Technology\", missing, missing)","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"","category":"page"},{"location":"basic_usage.html#Get-exchange-rates","page":"Basic usage","title":"Get exchange rates","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"# Same API as get_price. the symbol needs to be a currency pair like $base/$quote,\n# each consisting of exactly 3 characters.\njulia> ref_date = Date(\"2022-02-18\")\njulia> get_exchange_rate(\"EUR/USD\", from=ref_date-Day(1), to=ref_date)\n3-element Vector{ExchangeRate}:\n ExchangeRate(\"EUR\", \"USD\", Date(\"2022-02-18\"), 1.13203)\n ExchangeRate(\"EUR\", \"USD\", Date(\"2022-02-17\"), 1.13592)\njulia> get_exchange_rate([\"EUR/USD\", \"USD/CAD\"], from=ref_date-Day(1), to=ref_date)\n# 4-element Vector{ExchangeRate}:\n ExchangeRate(\"EUR\", \"USD\", Date(\"2022-02-18\"), 1.13203)\n ExchangeRate(\"EUR\", \"USD\", Date(\"2022-02-17\"), 1.13592)\n ExchangeRate(\"USD\", \"CAD\", Date(\"2022-02-18\"), 1.2748)\n ExchangeRate(\"USD\", \"CAD\", Date(\"2022-02-17\"), 1.2707)\n# Also works with []Tuple{String, Date} or []Tuple{String, Date, Date}\njulia>get_exchange_rate([\n  (\"EUR/USD\", Date(\"2022-02-15\"), Date(\"2022-02-16\")),\n  (\"USD/CAD\", Date(\"2022-02-14\"), Date(\"2022-02-15\")),\n])\n4-element Vector{ExchangeRate}:\n...","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"","category":"page"},{"location":"basic_usage.html#DataFrames-integration","page":"Basic usage","title":"DataFrames integration","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"The types of the DataFrame will match the types of any type model, T<:AbstractStonksRecord. Currently only tested with flat data types.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> data\n4-element Vector{AssetPrice}:\n AssetPrice(\"MSFT\", Date(\"2022-02-23\"), 280.27, 290.18, 291.7, 280.1, missing, 37811167)\n AssetPrice(\"AAPL\", Date(\"2022-02-23\"), 160.07, 165.54, 166.15, 159.75, missing, 90009247)\njulia> data |> to_dataframe\n4x8 DataFrame\n Row │ symbol  date        close    open      high      low       close_adjusted  volume   \n     │ String  Date        Float64  Float64?  Float64?  Float64?  Float64?        Int64?   \n─────┼─────────────────────────────────────────────────────────────────────────────────────\n   1 │ MSFT    2022-02-23   280.27    290.18    291.7     280.1          missing  37811167\n   3 │ AAPL    2022-02-23   160.07    165.54    166.15    159.75         missing  90009247","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"","category":"page"},{"location":"basic_usage.html#Persisting-data","page":"Basic usage","title":"Persisting data","text":"","category":"section"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Using a FileStore, you can easily persist and incrementaly update data having at least one identifier and one time dimension. Default file format is CSV, but you can plug in any format you wish. See example for custom file formats.","category":"page"},{"location":"basic_usage.html","page":"Basic usage","title":"Basic usage","text":"using Chain, Dates, DataFrames\nusing Stonks\n\ndest = joinpath(@__DIR__, \"data/prices\")\nds = FileStore{AssetPrice}(; path=dest, ids=[:symbol], partitions=[:symbol], time_column=\"date\")\nd_end = Date(\"2022-03-06\")\n2022-03-06\n\nsymbols = [\"AAPL\", \"MSFT\"]\ndata = get_price(symbols; from=d_end-Day(7), to=d_end-Day(5))\n\nsave(ds, data)\nprintln(readdir(dest))\n[\"symbol=AAPL\", \"symbol=MSFT\"] #data stored in partitions\ndf = load(ds)\nshow(df[1:2, :]) # types are persisted\n2×8 DataFrame\n Row │ symbol  date        close    open      high      low       close_adjusted  volume   \n     │ String  Date        Float64  Float64?  Float64?  Float64?  Float64?        Integer? \n─────┼─────────────────────────────────────────────────────────────────────────────────────\n   1 │ AAPL    2022-03-01   163.2    164.695    166.6     161.97         missing  83474425\n   2 │ AAPL    2022-02-28   165.12   163.06     165.42    162.43         missing  95056629\n\nshow_stats(ds) = @chain load(ds) begin  \n  groupby(_, :symbol) \n  combine(_, :date => maximum, :date => minimum, :symbol => length => :nrows)\n show\nend\n\nshow_stats(ds)\n2×4 DataFrame\n Row │ symbol  date_maximum  date_minimum  nrows \n     │ String  Date          Date          Int64 \n─────┼───────────────────────────────────────────\n   1 │ AAPL    2022-03-01    2022-02-28        2\n   2 │ MSFT    2022-03-01    2022-02-28        2\n\n# to is optional, defaults to latest workday. here, we need it for reproductible results.\nupdate(ds; to=d_end)\nshow_stats(ds) \n# d_end (2022-03-06) is a Sunday, so the latest available data is from a Friday (2022-03-04).\n2×4 DataFrame\n Row │ symbol  date_maximum  date_minimum  nrows \n     │ String  Date          Date          Int64 \n─────┼───────────────────────────────────────────\n   1 │ AAPL    2022-03-04    2022-02-28        6\n   2 │ MSFT    2022-03-04    2022-02-28        6\n\nd_start = d_end - Day(7)\n# we add 2 new stocks to our store.\nupdate(ds, [(\"IBM\", d_start, d_end), (\"AMD\", d_start, d_end)], to=d_end)\nshow_stats(ds)\n4×4 DataFrame\n Row │ symbol  date_maximum  date_minimum  nrows \n     │ String  Date          Date          Int64 \n─────┼───────────────────────────────────────────\n   1 │ AAPL    2022-03-04    2022-02-28        5\n   2 │ AMD     2022-03-04    2022-02-28        5\n   3 │ IBM     2022-03-04    2022-02-28        5\n   4 │ MSFT    2022-03-04    2022-02-28        5\n# update(ds, [\"IBM\", \"AMD\"]) - will include data since earliest available\n# update(ds, vcat(symbols, [\"IBM\", \"AMD\"])) - will also update the existing symbols, \n#  if there is new data","category":"page"},{"location":"index.html#Welcome","page":"Home","title":"Welcome","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Welcome to Stonks.jl documentation. The resource aims to give you all the information needed about this package. Weather you need just the basics in order to get started, or have more advanced use cases for which you meed to extend the functionality, you should find your answers here.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#About","page":"Home","title":"About","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Stonks.jl is the Julia library that lets you access and store financial data from multiple APIs into a unified data model. It gives you the tools to generalize the data retrieval and storage from any API with a simple API in a type-safe manner.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"You want to analyze some financial data to optimize your portfolio, test some strategies, whatever. Quality historical data is hard to find for free. You might find the data you need, but scattered across several API providers, each with its own formats, parameters, rate limits, etc. You need to write lots of code and do a lot of validation in order to get the data you want.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Stonks.jl solves this problem by trying to find the best sources for financial data, parse them and return them into a type-safe form. It is highly extensible, allowing you to define any API resource and your own data types. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The next problem I encountered was that I wanted a reliable way to store data locally and update it from time to time with new data.  That problem is solved by FileStore, which can work with any file format. Supports data partitioning, writes are atomic, schema validation on read and write. Incrementally update everything in your \"local database\" with just one function.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Designed to work with several APIs in an agnostic way, where several APIs are capable of returning the same data.\nComes with a pre-defined data model (types), but you're free to design your own types.\nStore and update data locally with ease using the FileStore, which can work with any file format. Supports data partitioning, writes are atomic, schema validation on read and write. Incrementally update everything in your datastore with just one function.\nDataFrames integration\nBatching of multiple stock tickers if the API resource allows it, thus minimizing the number of requests.\nAsynchronous request processing. Multiple requests will processed asynchronously and multi-threaded, thus minimizing the network wait time.\nSilent by design. The main exposed functions for fetching and saving data don't throw an error, making your program crash. Instead, it will return the error with a descriptive message of what went wrong. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"index.md\", \"basic_usage.md\", \"advanced_usage.md\", \"api_types.md\", \"api_functions.md\", \"contributing.md\"]\nDepth = 2","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"api_types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api_types.html","page":"Types","title":"Types","text":"","category":"page"},{"location":"api_types.html#Index","page":"Types","title":"Index","text":"","category":"section"},{"location":"api_types.html","page":"Types","title":"Types","text":"Pages = [\"api_types.md\"]","category":"page"},{"location":"api_types.html","page":"Types","title":"Types","text":"","category":"page"},{"location":"api_types.html#Data-Models","page":"Types","title":"Data Models","text":"","category":"section"},{"location":"api_types.html","page":"Types","title":"Types","text":"Defines the types into which data will be deserialized.","category":"page"},{"location":"api_types.html","page":"Types","title":"Types","text":"AbstractStonksRecord\nAssetInfo\nAssetPrice\nExchangeRate","category":"page"},{"location":"api_types.html#Stonks.Models.AbstractStonksRecord","page":"Types","title":"Stonks.Models.AbstractStonksRecord","text":"Abstract type inteded to be subtyped by an data model.\n\nAll subtypes are constructed from keyword args and optional values default to missing.\n\n\n\n\n\n","category":"type"},{"location":"api_types.html#Stonks.Models.AssetInfo","page":"Types","title":"Stonks.Models.AssetInfo","text":"Stores general information about a quoted symbol / ticker.\n\nConstructors\n\nAssetInfo(;\n  symbol::String,\n  currency::String,\n  name::Union{String,Missing}=missing,\n  type::Union{String,Missing}=missing,\n  exchange::Union{String,Missing}=missing,\n  country::Union{String,Missing}=missing,\n  industry::Union{String,Missing}=missing,\n  sector::Union{String,Missing}=missing,\n  timezone::Union{String,Missing}=missing,\n  employees::Union{Integer,Missing}=missing,\n)\n\n\n\n\n\n","category":"type"},{"location":"api_types.html#Stonks.Models.AssetPrice","page":"Types","title":"Stonks.Models.AssetPrice","text":"Stores a time series datapoint with price information. Lowest frequency is daily.\n\nConstructors\n\nAssetPrice(\n  symbol::String,\n  date::Date,\n  close::Float64,\n  open::Union{Float64,Missing} = missing,\n  high::Union{Float64,Missing} = missing,\n  low::Union{Float64,Missing} = missing,\n  close_adjusted::Union{Float64,Missing} = missing,\n  volume::Union{Integer,Missing} = missing,\n)\nend\n\n\n\n\n\n","category":"type"},{"location":"api_types.html#Stonks.Models.ExchangeRate","page":"Types","title":"Stonks.Models.ExchangeRate","text":"Stores an exchange rate datapoint. Lowest frequency is daily.\n\nConstructors\n\nExchangeRate(;\n  base::String,\n  target::String,\n  date::Date,\n  rate::Float64,\n)\n\n\n\n\n\n","category":"type"},{"location":"api_types.html","page":"Types","title":"Types","text":"","category":"page"},{"location":"api_types.html#API-Clients","page":"Types","title":"API Clients","text":"","category":"section"},{"location":"api_types.html","page":"Types","title":"Types","text":"Stores information required to make requests HTTP APIs.","category":"page"},{"location":"api_types.html","page":"Types","title":"Types","text":"Stonks.APIClients.AbstractDataClient\nStonks.APIClients.APIResource\nStonks.APIClients.APIClient","category":"page"},{"location":"api_types.html#Stonks.APIClients.AbstractDataClient","page":"Types","title":"Stonks.APIClients.AbstractDataClient","text":"Abstract type to be subtyped by any type responsible for data retrieval, like HTTP API or web socket.\n\n\n\n\n\n","category":"type"},{"location":"api_types.html#Stonks.APIClients.APIResource","page":"Types","title":"Stonks.APIClients.APIResource","text":"APIResource{T<:AbstractStonksRecord}\n\nStores data required to make requests to an API resource.\n\nFields\n\nurl::String: the url of the API resource, excluding query parameters\nquery_params::Dict{String, String}: parameters used in the request\nparser::AbstractContentParser: a subtype of AbstractContentParser implementing parse_content\nheaders::Dict{String,String}: HTTP headers\nsymbol_key::String: indicates the identifier for the symbol\nmax_batch_size::Integer: the maximum number of symbols allowed in a single request\nmax_retries::Integer: how many times to retry a failed request\nrank_order::Integer: if multiple APIResource capable of handling T, the one with highest values is preffered.\n\nConstructors\n\nAPIResource{T}(;\n  url::String, \n  parser::AbstractContentParser,\n  headers::Dict{String, String} = Dict(),\n  query_params::Dict{String, String} = Dict(),\n  symbol_key::String = max_batch_size > 1 ? \"symbols\" : \"symbol\",\n  max_batch_size::String = 1,\n  max_retries::Integer = 0,\n  rank_order::Integer = 1,\n)\n\n\n\n\n\n","category":"type"},{"location":"api_types.html#Stonks.APIClients.APIClient","page":"Types","title":"Stonks.APIClients.APIClient","text":"Groups collection of APIResource. Can hold resources from the same or different API.\n\nFields\n\nresources::Dict{String,APIResource}\n[url::String]: for descriptive purposes. should be ommited if you mix in resources from different APIs.\n\nConstructors\n\nAPIClient(resources::Dict{String, APIResource}, url::String=\"\")\n\n\n\n\n\n","category":"type"},{"location":"api_types.html","page":"Types","title":"Types","text":"","category":"page"},{"location":"api_types.html#Content-Parsers","page":"Types","title":"Content Parsers","text":"","category":"section"},{"location":"api_types.html","page":"Types","title":"Types","text":"Parsers transform the content received from n HTTP request into a Vector{<:AbstractStonxRecord}","category":"page"},{"location":"api_types.html","page":"Types","title":"Types","text":"Stonks.Parsers.AbstractContentParser\nStonks.Parsers.JSONParser\nStonks.Parsers.CSVParser","category":"page"},{"location":"api_types.html#Stonks.Parsers.AbstractContentParser","page":"Types","title":"Stonks.Parsers.AbstractContentParser","text":"Abstract type to be subclassed by any type of parser.\n\n\n\n\n\n","category":"type"},{"location":"api_types.html#Stonks.Parsers.JSONParser","page":"Types","title":"Stonks.Parsers.JSONParser","text":"A wrapper type for a function implementing parse_content interface for JSON content.\n\n\n\n\n\n","category":"type"},{"location":"api_types.html#Stonks.Parsers.CSVParser","page":"Types","title":"Stonks.Parsers.CSVParser","text":"A wrapper type for a function implementing parse_content interface for CSV content.\n\n\n\n\n\n","category":"type"},{"location":"api_types.html","page":"Types","title":"Types","text":"","category":"page"},{"location":"api_types.html#Stores","page":"Types","title":"Stores","text":"","category":"section"},{"location":"api_types.html","page":"Types","title":"Types","text":"Responsible for persisting and retrieving data: Vector{<:AbstractStonxRecord}.","category":"page"},{"location":"api_types.html","page":"Types","title":"Types","text":"Stonks.Stores.AbstractStore\nFileStore","category":"page"},{"location":"api_types.html#Stonks.Stores.AbstractStore","page":"Types","title":"Stonks.Stores.AbstractStore","text":"Abstract type to be subtyped by all types of Stores, like FileStore. DatabaseStore.\n\n\n\n\n\n","category":"type"},{"location":"api_types.html#Stonks.Stores.FileStore","page":"Types","title":"Stonks.Stores.FileStore","text":"FileStore{T<:AbstractStonksRecord}\n\nStores all information needed for data storage and retrieval.\n\nFields\n\npath::String: absolute or relative path \nids::AbstractVector{AbstractString}: list of identifiers. maximum 2 identifiers\nformat::String: file format. all files will have the ending like \"data.{format}\". default = \"csv\"\npartitions::AbstractVector{AbstractString}: columns used for data partitioning. columns have to be members of T\ntime_colum::Union{AbstractString, Missing}: column representing time dimension. Can be skipped for AssetPrice and ExchangeRate.\nreader::Function: reader(path::String) -> DataFrame\nwriter::Function: writer(df::AbstractDataFrame, path::String) -> DataFrame\n\nConstructors\n\nFileStore{<:AbstractStonksRecord}(;\n  path,\n  ids,\n  format=\"csv\",\n  partitions=[],\n  time_column=missing,\n  reader=reader_csv,\n  writer=writer_csv,\n)\n\n# where,\nreader_csv(path::String) = DataFrame(CSV.File(path))\nwriter_csv(df::AbstractDataFrame, path::String) = CSV.write(path, df)\n\nExamples\n\nusing Stonks\ndest = joinpath(@__DIR__, \"data/stonks\")\nFileStore{AssetInfo}(; path=dest, ids=[\"symbol\"])\nFileStore{AssetPrice}(; path=dest, ids=[\"symbol\"], time_column=\"date\")\nFileStore{AssetPrice}(; path=dest, ids=[:symbol], partitions=[:symbol], time_column =\"date\")\n\nusing Arrow, DataFrames\nread = read_arrow(path::String) = Arrow.Table(path) |> DataFrame\nwrite = write_arrow(df::AbstractDataFrame, path::String) = open(path, \"w\") do io Arrow.write(io, df) end\nFileStore{ExchangeRate}(; path=dest, ids=[:base, :target], time_column=\"date\", reader=read, writer=write)\n\n\n\n\n\n","category":"type"}]
}
